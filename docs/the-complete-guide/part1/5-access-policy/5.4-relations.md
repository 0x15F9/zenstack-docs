---
sidebar_label: 5.4 Working With Relations
slug: relations
---

# Working With Relations

In the previous chapters, we've learned how to write basic policy rules involving model fields and the current user. However, real-world applications usually have authorization requirements that need to access relations. Here're are some examples:

- A `Todo` is readable if its parent `TodoList` is not private.
- A `Post` is readable if the current user is a member of the `Organization` that the `Post` belongs to.

In this chapter, we'll learn how to write policy rules that involve relations.

### *-to-one Relations

Accessing *-to-one relation is straightforward. You simply reference the field directly. You can further visit the relation's fields using the dot notation.

```zmodel
model TodoList {
    id Int
    private Boolean
}

model Todo {
    id Int
    list TodoList @relation(...)

    // `list` references a to-one relation
    @@allow('update', !list.private)
}
```

You can chain the dot notation to make deep traversal in the relation graph. There's no limit on how deep you can go.

### *-to-many Relations

To-many relations are a bit more complicated because you're dealing with a list of objects instead of one. The authorization conditions written with to-many relations can be one of the the following three forms:

- Does any of the objects in the list satisfy the condition?
- Does all of the objects in the list satisfy the condition?
- Does none of the objects in the list satisfy the condition?

ZenStack provides a succinct syntax called "Collection Predicate Expression" for writing such rules:

```
Any:  relation?[condition]
All:  relation![condition]
None: relation^[condition]
```

The `relation` part refers to a to-many relation field. The `condition` part is a boolean expression that that is scoped to the type of `relation`. I.e., it can reference the member fields of `relation` without any qualification.

:::info

A collection predicate expression must start with a to-many relation field. You can't use a simple array field (like `String[]`) with it. In the next chapter you'll learn about helper functions that help you work with simple array.

:::

A few examples:

```zmodel

enum Role {
    ADMIN
    MEMBER
}

model User {
    ...
}

// join table for many-to-many relation between `User` and `Organization`
model Membership {
    id Int @id @default(autoincrement())
    role Role
    user User @relation(fields: [userId], references: [id])
    userId String
    org Organization @relation(fields: [orgId], references: [id])
    orgId Int
}

model Organization {
    id Int @id @default(autoincrement())
    members Membership[]
    ...

    // any user in the org can read the org
    @@allow('read', members?[user == auth()])

    // org admin can update and delete
    @@allow('update,delete', members?[user == auth() && role == ADMIN])
}
```

You can nest collection predicate expressions to do a deep traversal. The following example shows a traversal involving two to-many relations and one to-one relation:

```zmodel
model User {
    ...
    memberships Membership[]

    // current user can read users who have common orgs with him
    @@allow('read', memberships?[org.members?[user == auth()]])
}

model Membership {
    id Int @id @default(autoincrement())
    user User @relation(fields: [userId], references: [id])
    userId String
    org Organization @relation(fields: [orgId], references: [id])
    orgId Int
}

model Organization {
    id Int @id @default(autoincrement())
    members Membership[]
    ...
}
```
