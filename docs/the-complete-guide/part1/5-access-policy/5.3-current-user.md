---
sidebar_label: 5.3 Accessing Current User
slug: current-user
---

# Accessing Current User

In most cases, whether a CRUD operation is allowed depends on the current user. ZenStack provides a special function `auth()` to access the current user in policy rules.

### Auth Model

When ZModel is compiled, the `auth()` function needs to be resolved to a data model so that the compiler knows which fields are accessible from the function. By default, the model named "User" is used as the auth model. Here's is an example:

```zmodel
model User {
    id Int @id
    role String
    posts Post[]
}

model Post {
    id Int @id
    title String
    author User @relation(fields: [authorId], references: [id])
    authorId Int

    // ✅ valid rule
    @@allow('all', auth().role == 'ADMIN')

    // ❌ invalid rule, `subscribed` field doesn't exist in `User` model
    @@allow('all', auth().subscribed == true) 
}
```

You can use a model not named `User` as the auth model by adding the `@@auth` attribute to it.

```zmodel
model MyUser {
    id Int @id
    role String
    posts Post[]

    @@auth
}
```

### Providing Current User

Since ZenStack is not an authentication solution, it doesn't really know who the current user is. It's up to the developer to get it from the authentication side and pass it to ZenStack (when calling the `enhance` function).

Here's the pseudo code:

```ts

// `getCurrentUser` is an authentication API that extracts 
// the current user from the request
const user = await getCurrentUser(request);

// create an enhanced Prisma Client for the user, the `user` object
// provides value for the `auth()` function in policy rules
const db = enhance(prisma, { user })
```

The minimum requirement for the `user` object is that it must have value for the "id" field of the auth model (if the model uses compound id fields, all fields need to be assigned). At runtime, ZenStack detects if fields that are not provided are needed for evaluating policy rules, and if so, it fetches them from the database.

:::tip

For optimal performance, try to provide all fields used in policy rules in the `user` object to save a database query.

:::

### Writing Conditions With `auth()`

#### Checking Anonymous User

You can indicate that the current user is anonymous by not passing the `user` object (or passing `undefined`) when calling `enhance`:

```ts
const db = enhance(prisma);
```

In policy rules, check `auth() == null` for anonymous user:

```zmodel
model Post {
    ...

    // allow all login users to read
    @@allow('read', auth() != null)
}
```

#### Comparing `auth()` With Other Fields

You can compare `auth()` against a field of the same type (i.e., the auth model). Such comparison is equivalent to an id field comparison. For example, the following policy rule:

```zmodel
model Post {
    ...
    author User @relation(fields: [authorId], references: [id])
    authorId Int
    @@allow('update', auth() == author)
}
```

is equivalent to:

```zmodel
model Post {
    ...
    author User @relation(fields: [authorId], references: [id])
    authorId Int
    @@allow('update', auth().id == author.id)
}
```

, and is also equivalent to:

```zmodel
model Post {
    ...
    author User @relation(fields: [authorId], references: [id])
    authorId Int
    @@allow('update', auth().id == authorId)
}
```

#### Traversing Relation Fields

You can access auth model's relation fields from `auth()` function, and chain them with other fields. ZenStack automatically fetches the relation fields from the database when evaluating the rules.

```zmodel
model User {
    ...
    role Role
}

model Role {
    ...
    permissions Permission[]
}

model Permission {
    ...
    name String  // READ, WRITE, etc.
}

model Post {
    ...

    @@allow('read', auth().role.permissions?[name == 'READ'])
}
```

:::info

The `expression?[condition]` syntax used above is called "Collection Predicate Expression". It's used for computing a boolean value from a "*-to-many" relation field. You'll learn more about it in the next chapter.

:::
